#!/usr/bin/perl
use strict;
use warnings;
use feature qw/say/;

#
# Clone an MT19937 RNG from its output
# 

#use Crypto::MT19937 qw/:all/;
use Crypto::Prng;
use English;

## MT19937 globals 
my @state;
my $index = 0;

my( $w, $n, $m, $r ) = (32, 624, 397, 31);

my $lower_mask = 0x80000000;
my $upper_mask = 0x7fffffff;

my( $u, $d ) = (11, 0xFFFFFFFF);
my( $s, $b ) = (7, 0x9D2C5680);
my( $t, $c ) = (15, 0xEFC60000);
my $a = 0x9908B0DF;
my $l = 18;
my $f = 1812433253;
## end MT19937 globals

my $seed = 203;			# random seed!
my $prng = Crypto::Prng->new();	
$prng->seed($seed);		# seed the generator

&test_untemper;
&clone_state();
&solve_challenge;

sub solve_challenge {
# check we can predict numbers generated
    my $checks = 100;

    my $failed = 0;
    print "Set 2 Challenge 23: ";
    for (1 .. $checks) {
	my $pred = &l_extract_number;
	my $gen = $prng->extract_number;
	if ($pred != $gen) {
	    $failed = 1;
	} 
    }
    if ($failed == 0) {
	print "Completed!\n";
    } else {
	print "Failed\n";	
    }
}

sub clone_state {

    for (1 .. $n) {
	my $v = $prng->extract_number;
	my $seed = untemper( $v );
	push @state, $seed;
	$index++;
    }
#    &dump_state(10);
}


# from MT19937 extract_number
sub temper {
    my( $y ) = @_;
    
    $y = $y ^ (($y >> $u));	 # u
    $y = $y ^ (($y << $s) & $b); # s
    $y = $y ^ (($y << $t) & $c); # t
    $y = $y ^ ($y >> $l);	 # l

    return int32( $y );
}

# given 32 bit integer generated by MT19337 returns 'un-tempered' state value
sub untemper {
    my( $y ) = @_;
    				# reverse order: l t s u
    $y = inv_right_n( $y, $l );	        # l
    $y =  inv_left_n_and( $y, $t, $c ); # t
    $y =  inv_left_n_and( $y, $s, $b ); # s
    $y = inv_right_n( $y, $u );		# u
    return int32( $y );
}

sub inv_left_n_and {
    my( $y, $shift, $mask ) = @_;
    my $nrecovered = 0;

    my $r = $y;
    $nrecovered = $shift;

    while ($nrecovered < 32) {
	$r = $y ^ ($r << $shift & $mask);
	$nrecovered += $shift;
    }

    return $r;
}

# inverts y = y ^ (y >> N)
sub inv_right {
    my( $y, $shift ) = @_;
    my $last = $y >> $shift;
    return $y ^ $last;
}

sub test_untemper {
    my @vals = @_;

    my @gen_seeds = ( 203, 2851730200, 1886114628, 4051519292 ); # seeds in state
    my @gen = ( 570707146, 1389021844, 2219829549, 3842315221 ); # generated ints

    for (1 .. 10) {
	my $seed = int(rand(2**32));
	my $tempered = &temper( $seed );
	my $untempered = &untemper( $tempered );
	if ($untempered != $seed) {
	    print "untemper fail on loop: $_\n";
	}
    }
    
    for my $seed (@gen_seeds) {
    	my $tempered = &temper( $seed );
    	my $untempered = &untemper( $tempered );
    	if ($untempered != $seed) {
    	    print "untemper fail for seed: $seed\n";
    	}
    }
}
#
##### From MT19337
#
# Extract a tempered value based on $state[index], calling twist() every n numbers
sub l_extract_number {
    if ($index >= $n) {
	if ($index > $n) {
	    die "Generator was not seeded\n";
	}
	&l_twist();
    }
    my $y = $state[$index];
    $y = $y ^ (($y >> $u));
    $y = $y ^ (($y << $s) & $b);
    $y = $y ^ (($y << $t) & $c);
    $y = $y ^ ($y >> $l);

    $index++;		
    return int32( $y );
}

# Generate the next n values from the series x_i 
sub l_twist {
    for (0 .. $n-1) {
	my $x = ($state[$_] & $upper_mask) + ($state[($_ + 1) % $n] & $lower_mask);
	my $xA = $x >> 1;
	if (($x % 2) != 0) {
	    $xA = $xA ^ $a;
	}
	$state[$_] = $state[($_ + $m) % $n] ^ $xA;
    }
    $index = 0;
}
# Get the 32 least significant bits.
sub int32 {
    my $n = shift;
    return int(0xFFFFFFFF & $n)
}
#
#####
#
sub dump_state {
    my( $loop, $which ) = @_;
    my $gen_state = &get_state;

    printf "\nstate %s : %s\n", "local", "gen";
    print "----------------------\n";
    for (1 .. $loop) {
	if (! defined $which) {
	    printf "%10s : %s\n", $state[$_-1], $$gen_state[$_-1];	    
	} else {
	    printf "%10s : %s\n", "***", $$gen_state[$_-1];	    
	}
    }
}

#
# From chal-23.pl: Implementation using bit strings, keep for reference
#

# inverts y = y ^ (y >> N)
sub inv_right_n {
    my( $b, $n ) = @_;
    my $input = dec2bits($b);
    my $shifted = "0" x $n;		# most significant bit (leftmost)
    my $output = "";
				# build $output
    for (0 .. 31) {
	my $bit = &sb_xor(substr($input, $_, 1), substr($shifted, $_, 1));
	substr($output, $_, 1) = $bit;
	if ($_ < (32 - $n)) {		# exclude last loop iteration
	    substr($shifted, ($n + $_), 1) = $bit;   
	}
    }
    return bits2dec($output);
}

# string (single) bit xor
sub sb_xor {
    my( $a, $b ) = @_;
    my $sum = $a + $b;
    if ($sum == 1) {
	return "1";
    } else {
	return "0";
    }
}

sub bits2dec {
    my $bits = shift;
    $bits = "0b" . $bits;
    oct($bits);
}

sub dec2bits {
    my $str = unpack("B32", pack("N", shift));    
}

sub test_bit_conversion {
    my $val = 630;
    my $bits = dec2bits( $val );
    my $rinsed = bits2dec( $bits );
    if ($rinsed != $val) {
	print "bit_conversion failed\n";
    }
}
